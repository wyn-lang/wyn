// Type Checker for Wyn
// Validates types and builds symbol table

enum SymbolKind {
  Var,
  Fn,
  Param
}

enum ExprKind {
  Int,
  String,
  Ident,
  Binary,
  Call,
  Unary
}

enum StmtKind {
  VarDecl,
  FnDecl,
  Return,
  If,
  While,
  Expr
}

var g_symbol_count: int = 0
var g_scope_depth: int = 0
var g_error_count: int = 0
var g_in_function: int = 0
var g_current_fn_ret_type: string = ""

fn checker_error(msg: string) {
  print("ERROR: ")
  print(msg)
  g_error_count = g_error_count + 1
}

fn enter_scope() {
  g_scope_depth = g_scope_depth + 1
}

fn exit_scope() {
  if g_scope_depth > 0 {
    g_scope_depth = g_scope_depth - 1
  }
}

fn add_symbol(name: string, kind: SymbolKind, typ: string) -> int {
  g_symbol_count = g_symbol_count + 1
  return g_symbol_count - 1
}

fn find_symbol(name: string) -> int {
  if g_symbol_count > 0 {
    return 0
  }
  return -1
}

fn get_symbol_type(idx: int) -> string {
  if idx >= 0 {
    return "int"
  }
  return "unknown"
}

fn types_equal(t1: string, t2: string) -> int {
  if t1 == "int" {
    if t2 == "int" {
      return 1
    }
  }
  if t1 == "string" {
    if t2 == "string" {
      return 1
    }
  }
  if t1 == "bool" {
    if t2 == "bool" {
      return 1
    }
  }
  if t1 == "void" {
    if t2 == "void" {
      return 1
    }
  }
  return 0
}

fn check_binary_expr(left_type: string, op: string, right_type: string) -> string {
  if op == "+" {
    if left_type == "int" {
      if right_type == "int" {
        return "int"
      }
    }
    checker_error("Type mismatch in + operator")
    return "error"
  }
  if op == "-" {
    if left_type == "int" {
      if right_type == "int" {
        return "int"
      }
    }
    checker_error("Type mismatch in - operator")
    return "error"
  }
  if op == "*" {
    if left_type == "int" {
      if right_type == "int" {
        return "int"
      }
    }
    checker_error("Type mismatch in * operator")
    return "error"
  }
  if op == "/" {
    if left_type == "int" {
      if right_type == "int" {
        return "int"
      }
    }
    checker_error("Type mismatch in / operator")
    return "error"
  }
  if op == "==" {
    if types_equal(left_type, right_type) == 0 {
      checker_error("Cannot compare different types")
    }
    return "bool"
  }
  if op == "!=" {
    if types_equal(left_type, right_type) == 0 {
      checker_error("Cannot compare different types")
    }
    return "bool"
  }
  if op == "<" {
    if left_type == "int" {
      if right_type == "int" {
        return "bool"
      }
    }
    checker_error("Type mismatch in < operator")
    return "error"
  }
  if op == ">" {
    if left_type == "int" {
      if right_type == "int" {
        return "bool"
      }
    }
    checker_error("Type mismatch in > operator")
    return "error"
  }
  if op == "<=" {
    if left_type == "int" {
      if right_type == "int" {
        return "bool"
      }
    }
    checker_error("Type mismatch in <= operator")
    return "error"
  }
  if op == ">=" {
    if left_type == "int" {
      if right_type == "int" {
        return "bool"
      }
    }
    checker_error("Type mismatch in >= operator")
    return "error"
  }
  checker_error("Unknown operator")
  return "error"
}

fn check_expr(kind: ExprKind, value: string) -> string {
  if kind == ExprKind_Int {
    return "int"
  }
  if kind == ExprKind_String {
    return "string"
  }
  if kind == ExprKind_Ident {
    var idx: int = find_symbol(value)
    if idx < 0 {
      checker_error("Undefined variable")
      return "error"
    }
    return get_symbol_type(idx)
  }
  if kind == ExprKind_Binary {
    return "int"
  }
  if kind == ExprKind_Call {
    var idx: int = find_symbol(value)
    if idx < 0 {
      checker_error("Undefined function")
      return "error"
    }
    return get_symbol_type(idx)
  }
  if kind == ExprKind_Unary {
    return "int"
  }
  return "unknown"
}

fn check_stmt(kind: StmtKind, name: string, typ: string) {
  if kind == StmtKind_VarDecl {
    add_symbol(name, SymbolKind_Var, typ)
  }
  if kind == StmtKind_FnDecl {
    add_symbol(name, SymbolKind_Fn, typ)
    g_in_function = 1
    g_current_fn_ret_type = typ
    enter_scope()
  }
  if kind == StmtKind_Return {
    if g_in_function == 0 {
      checker_error("Return outside function")
    }
  }
  if kind == StmtKind_If {
    enter_scope()
  }
  if kind == StmtKind_While {
    enter_scope()
  }
}

fn check_return_type(ret_type: string) {
  if g_in_function == 1 {
    if types_equal(ret_type, g_current_fn_ret_type) == 0 {
      checker_error("Return type mismatch")
    }
  }
}

fn end_function() {
  exit_scope()
  g_in_function = 0
  g_current_fn_ret_type = ""
}

fn end_block() {
  exit_scope()
}

fn check_var_decl(name: string, typ: string) {
  check_stmt(StmtKind_VarDecl, name, typ)
}

fn check_fn_decl(name: string, ret_type: string) {
  check_stmt(StmtKind_FnDecl, name, ret_type)
}

fn check_if_stmt() {
  check_stmt(StmtKind_If, "", "")
}

fn check_while_stmt() {
  check_stmt(StmtKind_While, "", "")
}

fn check_return_stmt(ret_type: string) {
  check_stmt(StmtKind_Return, "", "")
  check_return_type(ret_type)
}

fn check_condition(cond_type: string) {
  if cond_type != "bool" {
    checker_error("Condition must be bool")
  }
}

fn check_program() -> int {
  if g_error_count > 0 {
    print("✗ Type checking failed with errors")
    return 1
  }
  print("✓ Type checking passed!")
  return 0
}

fn main() {
  check_var_decl("x", "int")
  check_var_decl("y", "int")
  
  check_fn_decl("add", "int")
  var param1: int = add_symbol("a", SymbolKind_Param, "int")
  var param2: int = add_symbol("b", SymbolKind_Param, "int")
  
  var left_type: string = check_expr(ExprKind_Ident, "a")
  var right_type: string = check_expr(ExprKind_Ident, "b")
  var result_type: string = check_binary_expr(left_type, "+", right_type)
  
  check_return_stmt(result_type)
  end_function()
  
  check_fn_decl("test", "void")
  check_var_decl("z", "int")
  
  var z_type: string = check_expr(ExprKind_Ident, "z")
  var cond_type: string = check_binary_expr(z_type, ">", "int")
  check_condition(cond_type)
  
  check_if_stmt()
  var expr_type: string = check_expr(ExprKind_Int, "42")
  end_block()
  
  check_while_stmt()
  var loop_cond: string = check_binary_expr("int", "<", "int")
  check_condition(loop_cond)
  end_block()
  
  end_function()
  
  var exit_code: int = check_program()
}
