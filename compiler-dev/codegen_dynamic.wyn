// Dynamic Code Generator - Parses tokens and generates C code

var g_tokens: string = ""
var g_pos: int = 0
var g_output: string = ""

fn emit(s: string) -> int {
    g_output = g_output + s
    return 0
}

fn peek() -> string {
    if g_pos >= g_tokens.len() { return "EOF" }
    var end = g_pos
    while end < g_tokens.len() {
        var c = g_tokens.substring(end, end + 1)
        if c == "," { break }
        end = end + 1
    }
    return g_tokens.substring(g_pos, end)
}

fn advance() -> string {
    var tok = peek()
    if tok == "EOF" { return "EOF" }
    g_pos = g_pos + tok.len()
    if g_pos < g_tokens.len() {
        var c = g_tokens.substring(g_pos, g_pos + 1)
        if c == "," { g_pos = g_pos + 1 }
    }
    return tok
}

fn expect(s: string) -> int {
    var tok = advance()
    if tok != s {
        print("Expected ")
        print(s)
        print(" but got ")
        print(tok)
        println()
    }
    return 0
}

fn parse_fn() -> int {
    expect("FN")
    var name_tok = advance()
    if name_tok == "EOF" { return 0 }
    var name = name_tok.substring(3, name_tok.len())
    
    expect("LPAREN")
    var params = ""
    var first = 1
    var tok = peek()
    while tok != "RPAREN" {
        if tok == "EOF" { break }
        if first == 0 { params = params + ", " }
        first = 0
        var param_tok = advance()
        var param = param_tok.substring(3, param_tok.len())
        expect("COLON")
        var type_tok = advance()
        var typ = type_tok.substring(3, type_tok.len())
        params = params + typ + " " + param
        tok = peek()
        if tok == "COMMA" { advance() }
        tok = peek()
    }
    expect("RPAREN")
    expect("ARROW")
    var ret_tok = advance()
    var ret = ret_tok.substring(3, ret_tok.len())
    
    emit(ret)
    emit(" ")
    emit(name)
    emit("(")
    emit(params)
    emit(") {\n")
    
    expect("LBRACE")
    tok = peek()
    while tok != "RBRACE" {
        if tok == "EOF" { break }
        if tok == "RETURN" {
            advance()
            emit("  return ")
            var expr = advance()
            if expr.substring(0, 3) == "ID:" {
                emit(expr.substring(3, expr.len()))
            } else {
                emit(expr)
            }
            tok = peek()
            if tok == "PLUS" {
                advance()
                emit(" + ")
                var expr2 = advance()
                if expr2.substring(0, 3) == "ID:" {
                    emit(expr2.substring(3, expr2.len()))
                } else {
                    emit(expr2)
                }
            }
            emit(";\n")
        }
        tok = peek()
    }
    expect("RBRACE")
    emit("}\n\n")
    return 0
}

fn main() -> int {
    g_tokens = File::read("tokens.txt")
    emit("#include <stdio.h>\n\n")
    
    while g_pos < g_tokens.len() {
        var tok = peek()
        if tok == "EOF" { break }
        if tok == "FN" { parse_fn() }
        else { advance() }
    }
    
    File::write("output.c", g_output)
    print("Generated C code:\n")
    print(g_output)
    println()
    return 0
}
