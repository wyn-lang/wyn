// codegen_module.wyn - Enhanced implementation for bootstrap
// Generates C code that preserves program structure

struct ASTNode {
    node_type: int,
    value: string,
    left: int,
    right: int,
    extra: int
}

const NODE_INT = 0
const NODE_STRING = 1
const NODE_IDENT = 2
const NODE_BINARY = 3
const NODE_VAR_DECL = 4
const NODE_FN_DECL = 5
const NODE_RETURN = 6
const NODE_EXPR_STMT = 7
const NODE_BLOCK = 8
const NODE_IF = 9
const NODE_WHILE = 10
const NODE_CALL = 11

var g_ast: [ASTNode]
var g_output: string

fn emit(s: string) {
    g_output = g_output + s
}

fn codegen_expr(idx: int) {
    if idx < 0 || idx >= g_ast.len() {
        return
    }
    
    var node = g_ast[idx]
    
    if node.node_type == NODE_INT {
        emit(node.value)
        return
    }
    
    if node.node_type == NODE_STRING {
        emit("\"")
        emit(node.value)
        emit("\"")
        return
    }
    
    if node.node_type == NODE_IDENT {
        emit(node.value)
        return
    }
    
    if node.node_type == NODE_BINARY {
        emit("(")
        codegen_expr(node.left)
        emit(" ")
        emit(node.value)
        emit(" ")
        codegen_expr(node.right)
        emit(")")
        return
    }
    
    if node.node_type == NODE_CALL {
        if node.left >= 0 {
            codegen_expr(node.left)
        }
        emit("(")
        if node.right >= 0 {
            codegen_expr(node.right)
        }
        emit(")")
        return
    }
}

fn codegen_stmt(idx: int) {
    if idx < 0 || idx >= g_ast.len() {
        return
    }
    
    var node = g_ast[idx]
    
    if node.node_type == NODE_VAR_DECL {
        emit("    int ")
        emit(node.value)
        emit(" = ")
        if node.left >= 0 {
            codegen_expr(node.left)
        } else {
            emit("0")
        }
        emit(";\n")
        return
    }
    
    if node.node_type == NODE_RETURN {
        emit("    return ")
        if node.left >= 0 {
            codegen_expr(node.left)
        } else {
            emit("0")
        }
        emit(";\n")
        return
    }
    
    if node.node_type == NODE_EXPR_STMT {
        emit("    ")
        codegen_expr(node.left)
        emit(";\n")
        return
    }
}

fn codegen_function(idx: int) {
    if idx < 0 || idx >= g_ast.len() {
        return
    }
    
    var node = g_ast[idx]
    
    if node.node_type != NODE_FN_DECL {
        return
    }
    
    emit("int ")
    emit(node.value)
    emit("() {\n")
    
    if node.right >= 0 {
        codegen_stmt(node.right)
    }
    
    emit("}\n\n")
}

export fn generate(ast: [ASTNode]) -> string {
    g_ast = ast
    g_output = ""
    
    emit("#include <stdio.h>\n")
    emit("#include <stdlib.h>\n")
    emit("#include <string.h>\n\n")
    
    var i = 0
    var has_functions = 0
    
    while i < ast.len() {
        var node = ast[i]
        
        if node.node_type == NODE_FN_DECL {
            has_functions = 1
            codegen_function(i)
        }
        
        i = i + 1
    }
    
    if has_functions == 0 {
        emit("int main() {\n")
        
        var j = 0
        while j < ast.len() {
            var node = ast[j]
            if node.node_type == NODE_VAR_DECL || node.node_type == NODE_RETURN {
                codegen_stmt(j)
            }
            j = j + 1
        }
        
        emit("    return 0;\n}\n")
    }
    
    return g_output
}

fn main() -> int {
    return 0
}
