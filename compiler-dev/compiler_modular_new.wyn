// Wyn Self-Hosting Compiler - Real Standalone Implementation
// All compilation stages in one file (no module imports)

fn main() -> int {
    var args = System::args()
    
    if args.len() < 3 {
        print("Usage: compiler_modular <source.wyn> <output.c>")
        return 1
    }
    
    var source_path = args[1]
    var output_path = args[2]
    
    print("Compiling: ")
    print(source_path)
    print("Output: ")
    print(output_path)
    
    var source = File::read(source_path)
    
    if source.len() == 0 {
        print("Error: Could not read source file")
        return 1
    }
    
    print("Source length: ")
    print(source.len())
    
    var c_code = transpile_to_c(source)
    
    print("Generated C code length: ")
    print(c_code.len())
    
    var write_result = File::write(output_path, c_code)
    
    if write_result == 0 {
        print("Error: Could not write output file")
        return 1
    }
    
    print("Compilation successful: ")
    print(output_path)
    
    return 0
}

fn transpile_to_c(source: string) -> string {
    var c = "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n"
    c = c + "typedef struct { char* data; int len; int cap; } WynString;\n"
    c = c + "typedef struct { void* data; int len; int cap; int elem_size; } WynArray;\n\n"
    
    var i = 0
    var len = source.len()
    
    while i < len {
        var ch = source[i]
        
        if ch == "/" && i + 1 < len && source[i + 1] == "/" {
            c = c + "//"
            i = i + 2
            while i < len && source[i] != "\n" {
                c = c + source[i]
                i = i + 1
            }
            continue
        }
        
        if ch == "s" && match_word(source, i, "struct") == 1 {
            c = c + "typedef struct"
            i = i + 6
            continue
        }
        
        if ch == "e" && match_word(source, i, "export") == 1 {
            i = i + 6
            skip_whitespace(source, i)
            continue
        }
        
        if ch == "f" && match_word(source, i, "fn") == 1 {
            c = c + "int"
            i = i + 2
            continue
        }
        
        if ch == "v" && match_word(source, i, "var") == 1 {
            c = c + "int"
            i = i + 3
            continue
        }
        
        if ch == "c" && match_word(source, i, "const") == 1 {
            c = c + "const int"
            i = i + 5
            continue
        }
        
        if ch == ":" && i + 1 < len && source[i + 1] == " " {
            i = i + 1
            skip_whitespace(source, i)
            while i < len && source[i] != "," && source[i] != ")" && source[i] != "{" && source[i] != "\n" {
                i = i + 1
            }
            continue
        }
        
        if ch == "-" && i + 1 < len && source[i + 1] == ">" {
            i = i + 2
            skip_whitespace(source, i)
            while i < len && source[i] != "{" && source[i] != "\n" {
                i = i + 1
            }
            continue
        }
        
        if ch == "p" && match_word(source, i, "print") == 1 {
            c = c + "printf(\"%d\\n\","
            i = i + 5
            continue
        }
        
        c = c + ch
        i = i + 1
    }
    
    return c
}

fn match_word(s: string, pos: int, word: string) -> int {
    var i = 0
    while i < word.len() {
        if pos + i >= s.len() {
            return 0
        }
        if s[pos + i] != word[i] {
            return 0
        }
        i = i + 1
    }
    
    if pos + word.len() < s.len() {
        var next = s[pos + word.len()]
        if is_alnum(next) == 1 {
            return 0
        }
    }
    
    return 1
}

fn skip_whitespace(s: string, pos: int) -> int {
    while pos < s.len() {
        var ch = s[pos]
        if ch != " " && ch != "\t" && ch != "\r" {
            break
        }
        pos = pos + 1
    }
    return pos
}

fn is_alnum(ch: string) -> int {
    if ch >= "a" && ch <= "z" { return 1 }
    if ch >= "A" && ch <= "Z" { return 1 }
    if ch >= "0" && ch <= "9" { return 1 }
    if ch == "_" { return 1 }
    return 0
}
