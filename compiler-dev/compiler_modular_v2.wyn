// Wyn Self-Hosting Compiler - Standalone Version
// Minimal but real implementation without module imports

// Token structure
struct Token {
    tok_type: int,
    value: string
}

// Token types
const TOKEN_EOF = 0
const TOKEN_IDENT = 1
const TOKEN_INT = 2
const TOKEN_FN = 3
const TOKEN_VAR = 4
const TOKEN_RETURN = 5
const TOKEN_ARROW = 6
const TOKEN_LBRACE = 7
const TOKEN_RBRACE = 8
const TOKEN_LPAREN = 9
const TOKEN_RPAREN = 10
const TOKEN_EQUAL = 11
const TOKEN_PLUS = 12
const TOKEN_MINUS = 13

// Simple lexer
fn tokenize(source: string) -> [Token] {
    var tokens: [Token]
    var pos = 0
    
    while pos < source.len() {
        var ch = source[pos]
        
        // Skip whitespace
        if ch == " " || ch == "\n" || ch == "\t" || ch == "\r" {
            pos = pos + 1
            continue
        }
        
        // Identifiers and keywords
        if (ch >= "a" && ch <= "z") || (ch >= "A" && ch <= "Z") {
            var start = pos
            while pos < source.len() {
                var c = source[pos]
                if (c >= "a" && c <= "z") || (c >= "A" && c <= "Z") || (c >= "0" && c <= "9") || c == "_" {
                    pos = pos + 1
                } else {
                    break
                }
            }
            var word = source.substring(start, pos)
            
            var tok_type = TOKEN_IDENT
            if word == "fn" { tok_type = TOKEN_FN }
            if word == "var" { tok_type = TOKEN_VAR }
            if word == "return" { tok_type = TOKEN_RETURN }
            
            tokens.push(Token { tok_type: tok_type, value: word })
            continue
        }
        
        // Numbers
        if ch >= "0" && ch <= "9" {
            var start = pos
            while pos < source.len() && source[pos] >= "0" && source[pos] <= "9" {
                pos = pos + 1
            }
            tokens.push(Token { tok_type: TOKEN_INT, value: source.substring(start, pos) })
            continue
        }
        
        // Operators and punctuation
        if ch == "=" { tokens.push(Token { tok_type: TOKEN_EQUAL, value: "=" }); pos = pos + 1; continue }
        if ch == "+" { tokens.push(Token { tok_type: TOKEN_PLUS, value: "+" }); pos = pos + 1; continue }
        if ch == "-" {
            if pos + 1 < source.len() && source[pos + 1] == ">" {
                tokens.push(Token { tok_type: TOKEN_ARROW, value: "->" })
                pos = pos + 2
                continue
            }
            tokens.push(Token { tok_type: TOKEN_MINUS, value: "-" })
            pos = pos + 1
            continue
        }
        if ch == "{" { tokens.push(Token { tok_type: TOKEN_LBRACE, value: "{" }); pos = pos + 1; continue }
        if ch == "}" { tokens.push(Token { tok_type: TOKEN_RBRACE, value: "}" }); pos = pos + 1; continue }
        if ch == "(" { tokens.push(Token { tok_type: TOKEN_LPAREN, value: "(" }); pos = pos + 1; continue }
        if ch == ")" { tokens.push(Token { tok_type: TOKEN_RPAREN, value: ")" }); pos = pos + 1; continue }
        
        pos = pos + 1
    }
    
    tokens.push(Token { tok_type: TOKEN_EOF, value: "" })
    return tokens
}

// Simple code generator
fn generate_c(tokens: [Token]) -> string {
    var output = "#include <stdio.h>\n#include <stdlib.h>\n\n"
    var i = 0
    
    while i < tokens.len() {
        var tok = tokens[i]
        
        // Function declaration: fn name() -> int { ... }
        if tok.tok_type == TOKEN_FN {
            i = i + 1
            if i >= tokens.len() { break }
            var fn_name = tokens[i].value
            
            // Skip parameters and return type
            while i < tokens.len() && tokens[i].tok_type != TOKEN_LBRACE {
                i = i + 1
            }
            
            output = output + "int " + fn_name + "() {\n"
            i = i + 1
            
            // Process function body
            while i < tokens.len() && tokens[i].tok_type != TOKEN_RBRACE {
                var body_tok = tokens[i]
                
                // var x = 42
                if body_tok.tok_type == TOKEN_VAR {
                    i = i + 1
                    if i >= tokens.len() { break }
                    var var_name = tokens[i].value
                    i = i + 1
                    
                    // Skip =
                    if i < tokens.len() && tokens[i].tok_type == TOKEN_EQUAL {
                        i = i + 1
                    }
                    
                    // Get value
                    if i < tokens.len() {
                        var value = tokens[i].value
                        output = output + "    int " + var_name + " = " + value + ";\n"
                        i = i + 1
                    }
                    continue
                }
                
                // return x
                if body_tok.tok_type == TOKEN_RETURN {
                    i = i + 1
                    if i < tokens.len() && tokens[i].tok_type != TOKEN_RBRACE {
                        var ret_val = tokens[i].value
                        output = output + "    return " + ret_val + ";\n"
                        i = i + 1
                    }
                    continue
                }
                
                i = i + 1
            }
            
            output = output + "}\n\n"
            i = i + 1
            continue
        }
        
        i = i + 1
    }
    
    return output
}

fn compile(source_path: string) -> int {
    var source = File::read(source_path)
    
    if source.len() == 0 {
        print("Error: Could not read source file")
        return 1
    }
    
    var tokens = tokenize(source)
    var c_code = generate_c(tokens)
    
    // Generate output path
    var output_path = source_path + ".c"
    var dot_pos = -1
    var i = source_path.len() - 1
    while i >= 0 {
        if source_path[i] == "." {
            dot_pos = i
            break
        }
        i = i - 1
    }
    if dot_pos >= 0 {
        output_path = source_path.substring(0, dot_pos) + ".c"
    }
    
    var result = File::write(output_path, c_code)
    if result == 0 {
        print("Error: Could not write output file")
        return 1
    }
    
    print("Compiled successfully: ")
    print(output_path)
    return 0
}

fn main() -> int {
    var args = System::args()
    
    var source_path = "/tmp/test_input.wyn"
    if args.len() >= 2 {
        source_path = args[1]
    }
    
    return compile(source_path)
}
