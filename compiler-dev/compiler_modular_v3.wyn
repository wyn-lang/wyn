// Wyn Self-Hosting Compiler - Standalone Version
// Minimal but real implementation without module imports

// Token structure
struct Token {
    tok_type: int,
    value: string
}

// Token types
const TOKEN_EOF = 0
const TOKEN_IDENT = 1
const TOKEN_INT = 2
const TOKEN_FN = 3
const TOKEN_VAR = 4
const TOKEN_RETURN = 5
const TOKEN_ARROW = 6
const TOKEN_LBRACE = 7
const TOKEN_RBRACE = 8
const TOKEN_LPAREN = 9
const TOKEN_RPAREN = 10
const TOKEN_EQUAL = 11
const TOKEN_PLUS = 12
const TOKEN_MINUS = 13
const TOKEN_COLON = 14

// Helper: check if character is whitespace
fn is_ws(ch: string) -> int {
    if ch == " " { return 1 }
    if ch == "\n" { return 1 }
    if ch == "\t" { return 1 }
    if ch == "\r" { return 1 }
    return 0
}

// Helper: check if character is alpha
fn is_alpha(ch: string) -> int {
    if ch >= "a" && ch <= "z" { return 1 }
    if ch >= "A" && ch <= "Z" { return 1 }
    if ch == "_" { return 1 }
    return 0
}

// Helper: check if character is digit
fn is_digit(ch: string) -> int {
    if ch >= "0" && ch <= "9" { return 1 }
    return 0
}

// Helper: check if character is alnum
fn is_alnum(ch: string) -> int {
    if is_alpha(ch) == 1 { return 1 }
    if is_digit(ch) == 1 { return 1 }
    return 0
}

// Simple lexer
fn tokenize(source: string) -> [Token] {
    var tokens: [Token]
    var pos = 0
    
    while pos < source.len() {
        var ch = source[pos]
        
        // Skip whitespace
        if is_ws(ch) == 1 {
            pos = pos + 1
        } else if is_alpha(ch) == 1 {
            // Identifiers and keywords
            var start = pos
            while pos < source.len() && is_alnum(source[pos]) == 1 {
                pos = pos + 1
            }
            var word = source.substring(start, pos)
            
            var tok_type = TOKEN_IDENT
            if word == "fn" { tok_type = TOKEN_FN }
            if word == "var" { tok_type = TOKEN_VAR }
            if word == "return" { tok_type = TOKEN_RETURN }
            if word == "int" { tok_type = TOKEN_IDENT }
            
            tokens.push(Token { tok_type: tok_type, value: word })
        } else if is_digit(ch) == 1 {
            // Numbers
            var start = pos
            while pos < source.len() && is_digit(source[pos]) == 1 {
                pos = pos + 1
            }
            tokens.push(Token { tok_type: TOKEN_INT, value: source.substring(start, pos) })
        } else if ch == "=" {
            tokens.push(Token { tok_type: TOKEN_EQUAL, value: "=" })
            pos = pos + 1
        } else if ch == "+" {
            tokens.push(Token { tok_type: TOKEN_PLUS, value: "+" })
            pos = pos + 1
        } else if ch == "-" {
            if pos + 1 < source.len() && source[pos + 1] == ">" {
                tokens.push(Token { tok_type: TOKEN_ARROW, value: "->" })
                pos = pos + 2
            } else {
                tokens.push(Token { tok_type: TOKEN_MINUS, value: "-" })
                pos = pos + 1
            }
        } else if ch == "{" {
            tokens.push(Token { tok_type: TOKEN_LBRACE, value: "{" })
            pos = pos + 1
        } else if ch == "}" {
            tokens.push(Token { tok_type: TOKEN_RBRACE, value: "}" })
            pos = pos + 1
        } else if ch == "(" {
            tokens.push(Token { tok_type: TOKEN_LPAREN, value: "(" })
            pos = pos + 1
        } else if ch == ")" {
            tokens.push(Token { tok_type: TOKEN_RPAREN, value: ")" })
            pos = pos + 1
        } else if ch == ":" {
            tokens.push(Token { tok_type: TOKEN_COLON, value: ":" })
            pos = pos + 1
        } else {
            pos = pos + 1
        }
    }
    
    tokens.push(Token { tok_type: TOKEN_EOF, value: "" })
    return tokens
}

// Simple code generator
fn generate_c(tokens: [Token]) -> string {
    var output = "#include <stdio.h>\n#include <stdlib.h>\n\n"
    var i = 0
    
    while i < tokens.len() {
        var tok = tokens[i]
        
        // Function declaration: fn name() -> int { ... }
        if tok.tok_type == TOKEN_FN {
            i = i + 1
            if i >= tokens.len() { break }
            var fn_name = tokens[i].value
            
            // Skip parameters and return type until {
            while i < tokens.len() && tokens[i].tok_type != TOKEN_LBRACE {
                i = i + 1
            }
            
            output = output + "int " + fn_name + "() {\n"
            i = i + 1
            
            // Process function body
            while i < tokens.len() && tokens[i].tok_type != TOKEN_RBRACE {
                var body_tok = tokens[i]
                
                // var x = 42
                if body_tok.tok_type == TOKEN_VAR {
                    i = i + 1
                    if i >= tokens.len() { break }
                    var var_name = tokens[i].value
                    i = i + 1
                    
                    // Skip : int if present
                    if i < tokens.len() && tokens[i].tok_type == TOKEN_COLON {
                        i = i + 1
                        if i < tokens.len() {
                            i = i + 1
                        }
                    }
                    
                    // Skip =
                    if i < tokens.len() && tokens[i].tok_type == TOKEN_EQUAL {
                        i = i + 1
                    }
                    
                    // Get value
                    if i < tokens.len() {
                        var value = tokens[i].value
                        output = output + "    int " + var_name + " = " + value + ";\n"
                        i = i + 1
                    }
                } else if body_tok.tok_type == TOKEN_RETURN {
                    // return x
                    i = i + 1
                    if i < tokens.len() && tokens[i].tok_type != TOKEN_RBRACE {
                        var ret_val = tokens[i].value
                        output = output + "    return " + ret_val + ";\n"
                        i = i + 1
                    }
                } else {
                    i = i + 1
                }
            }
            
            output = output + "}\n\n"
            i = i + 1
        } else {
            i = i + 1
        }
    }
    
    return output
}

fn compile(source_path: string) -> int {
    var source = File::read(source_path)
    
    if source.len() == 0 {
        print("Error: Could not read source file")
        return 1
    }
    
    var tokens = tokenize(source)
    var c_code = generate_c(tokens)
    
    // Generate output path
    var output_path = source_path + ".c"
    var dot_pos = -1
    var i = source_path.len() - 1
    while i >= 0 {
        if source_path[i] == "." {
            dot_pos = i
            break
        }
        i = i - 1
    }
    if dot_pos >= 0 {
        output_path = source_path.substring(0, dot_pos) + ".c"
    }
    
    var result = File::write(output_path, c_code)
    if result == 0 {
        print("Error: Could not write output file")
        return 1
    }
    
    print("Compiled successfully: ")
    print(output_path)
    return 0
}

fn main() -> int {
    var args = System::args()
    
    var source_path = "/tmp/test_input.wyn"
    if args.len() >= 2 {
        source_path = args[1]
    }
    
    return compile(source_path)
}
