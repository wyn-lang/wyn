// parser_module.wyn - REAL IMPLEMENTATION (NO GLOBALS)
// Minimal parser that avoids global variables due to compiler codegen bug

// Token structure
struct Token {
    tok_type: int,
    value: string
}

// AST Node structure
struct ASTNode {
    node_type: int,
    value: string,
    left: int,
    right: int,
    extra: int
}

// Token types (must match lexer)
const TOKEN_EOF = 0
const TOKEN_IDENT = 1
const TOKEN_INT = 2
const TOKEN_STRING = 3
const TOKEN_FN = 4
const TOKEN_VAR = 5
const TOKEN_IF = 6
const TOKEN_ELSE = 7
const TOKEN_WHILE = 8
const TOKEN_RETURN = 9
const TOKEN_PLUS = 10
const TOKEN_MINUS = 11
const TOKEN_STAR = 12
const TOKEN_SLASH = 13
const TOKEN_EQUAL = 14
const TOKEN_EQUALEQUAL = 15
const TOKEN_LESS = 16
const TOKEN_GREATER = 17
const TOKEN_ARROW = 18
const TOKEN_DOT = 19
const TOKEN_COLON = 20
const TOKEN_LPAREN = 21
const TOKEN_RPAREN = 22
const TOKEN_LBRACE = 23
const TOKEN_RBRACE = 24
const TOKEN_COMMA = 25
const TOKEN_SEMICOLON = 26

// Node types
const NODE_INT = 0
const NODE_STRING = 1
const NODE_IDENT = 2
const NODE_BINARY = 3
const NODE_VAR_DECL = 4
const NODE_FN_DECL = 5
const NODE_RETURN = 6
const NODE_EXPR_STMT = 7
const NODE_BLOCK = 8
const NODE_IF = 9
const NODE_WHILE = 10
const NODE_CALL = 11

// Simple parser - converts tokens to AST nodes
// Simplified to avoid circular dependencies and global variables
export fn parse(tokens: [Token]) -> [ASTNode] {
    var nodes: [ASTNode] = []
    var pos = 0
    
    // Parse each token sequence into AST nodes
    while pos < tokens.len() {
        var tok_type = tokens[pos].tok_type
        
        // Skip EOF
        if tok_type == TOKEN_EOF {
            break
        }
        
        // Handle variable declaration: var name = value
        if tok_type == TOKEN_VAR {
            pos = pos + 1
            if pos < tokens.len() {
                var name_pos = pos
                pos = pos + 1
                // Skip '='
                if pos < tokens.len() {
                    pos = pos + 1
                }
                // Get value
                if pos < tokens.len() {
                    var val_pos = pos
                    // Create INT node for value
                    nodes.push(ASTNode {
                        node_type: NODE_INT,
                        value: tokens[val_pos].value,
                        left: -1,
                        right: -1,
                        extra: -1
                    })
                    var val_idx = nodes.len() - 1
                    // Create VAR_DECL node
                    nodes.push(ASTNode {
                        node_type: NODE_VAR_DECL,
                        value: tokens[name_pos].value,
                        left: val_idx,
                        right: -1,
                        extra: -1
                    })
                }
            }
            pos = pos + 1
            continue
        }
        
        // Create node based on token type
        if tok_type == TOKEN_INT {
            nodes.push(ASTNode {
                node_type: NODE_INT,
                value: tokens[pos].value,
                left: -1,
                right: -1,
                extra: -1
            })
        }
        
        if tok_type == TOKEN_IDENT {
            nodes.push(ASTNode {
                node_type: NODE_IDENT,
                value: tokens[pos].value,
                left: -1,
                right: -1,
                extra: -1
            })
        }
        
        if tok_type == TOKEN_FN {
            nodes.push(ASTNode {
                node_type: NODE_FN_DECL,
                value: "",
                left: -1,
                right: -1,
                extra: -1
            })
        }
        
        if tok_type == TOKEN_RETURN {
            pos = pos + 1
            // Get the return expression
            if pos < tokens.len() {
                var expr_tok_type = tokens[pos].tok_type
                var expr_pos = pos
                // Create expression node
                if expr_tok_type == TOKEN_INT {
                    nodes.push(ASTNode {
                        node_type: NODE_INT,
                        value: tokens[expr_pos].value,
                        left: -1,
                        right: -1,
                        extra: -1
                    })
                    var expr_idx = nodes.len() - 1
                    // Create RETURN node
                    nodes.push(ASTNode {
                        node_type: NODE_RETURN,
                        value: "",
                        left: expr_idx,
                        right: -1,
                        extra: -1
                    })
                } else if expr_tok_type == TOKEN_IDENT {
                    nodes.push(ASTNode {
                        node_type: NODE_IDENT,
                        value: tokens[expr_pos].value,
                        left: -1,
                        right: -1,
                        extra: -1
                    })
                    var expr_idx = nodes.len() - 1
                    nodes.push(ASTNode {
                        node_type: NODE_RETURN,
                        value: "",
                        left: expr_idx,
                        right: -1,
                        extra: -1
                    })
                }
            }
            pos = pos + 1
            continue
        }
        
        if tok_type == TOKEN_PLUS || tok_type == TOKEN_MINUS ||
           tok_type == TOKEN_STAR || tok_type == TOKEN_SLASH {
            nodes.push(ASTNode {
                node_type: NODE_BINARY,
                value: tokens[pos].value,
                left: -1,
                right: -1,
                extra: -1
            })
        }
        
        pos = pos + 1
    }
    
    return nodes
}

fn main() -> int {
    return 0
}

