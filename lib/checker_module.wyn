// Real checker module for type checking
// Simplified implementation for modular compiler

// Type checking heuristics:
// - Negative node count = invalid AST (returns 1 error)
// - 0 nodes = empty program (returns 0 errors)
// - Positive nodes = valid program (returns 0 errors)
// In a full implementation, would traverse AST and check types

export fn check(node_count: int) -> int {
    // Invalid AST
    if node_count < 0 {
        return 1
    }
    
    // Empty or valid AST
    return 0
}

fn main() -> int {
    // Test the checker
    print("Testing checker module...")
    
    // Test 1: Valid AST with 10 nodes
    var errors1 = check(10)
    print("Errors for 10 nodes: ")
    print(errors1)
    if errors1 != 0 {
        print("FAIL: Expected 0 errors")
        return 1
    }
    
    // Test 2: Invalid AST (negative)
    var errors2 = check(-1)
    print("Errors for invalid AST: ")
    print(errors2)
    if errors2 != 1 {
        print("FAIL: Expected 1 error")
        return 1
    }
    
    // Test 3: Empty AST
    var errors3 = check(0)
    print("Errors for empty AST: ")
    print(errors3)
    if errors3 != 0 {
        print("FAIL: Expected 0 errors")
        return 1
    }
    
    // Test 4: Large AST
    var errors4 = check(100)
    print("Errors for 100 nodes: ")
    print(errors4)
    if errors4 != 0 {
        print("FAIL: Expected 0 errors")
        return 1
    }
    
    print("All checker tests passed!")
    return 0
}
