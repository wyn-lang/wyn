// Wyn Code Generator - Generates C code from AST

enum NodeType {
    NodeInt,
    NodeString,
    NodeVariable,
    NodeVarDecl,
    NodeReturn,
    NodeExprStmt,
    NodeBinary,
    NodeFnDecl,
    NodeBlock,
    NodeIf,
    NodeWhile,
    NodeCall,
    NodeStructDecl,
    NodeEnumDecl,
    NodeMatch,
    NodeStructInit
}

struct ASTNode {
    node_type: NodeType,
    value: string,
    left: int,
    right: int,
    extra: int
}

var g_nodes: [ASTNode] = []
var g_output: string = ""

fn emit(s: string) -> int {
    g_output = g_output + s
    return 0
}

fn codegen_int(node: ASTNode) -> int {
    emit(node.value)
    return 0
}

fn codegen_string(node: ASTNode) -> int {
    emit("\"")
    emit(node.value)
    emit("\"")
    return 0
}

fn codegen_variable(node: ASTNode) -> int {
    emit(node.value)
    return 0
}

fn codegen_binary(node: ASTNode) -> int {
    emit("(")
    codegen_expr(node.left)
    emit(" ")
    emit(node.value)
    emit(" ")
    codegen_expr(node.right)
    emit(")")
    return 0
}

fn codegen_call(node: ASTNode) -> int {
    var fn_node = g_nodes[node.left]
    emit(fn_node.value)
    emit("(")
    var arg_idx = node.right
    var first = 1
    while arg_idx >= 0 {
        if first == 0 {
            emit(", ")
        }
        first = 0
        codegen_expr(arg_idx)
        var arg_node = g_nodes[arg_idx]
        arg_idx = arg_node.extra
    }
    emit(")")
    return 0
}

fn codegen_struct_init(node: ASTNode) -> int {
    emit("(")
    emit(node.value)
    emit("){")
    var field_idx = node.left
    var first = 1
    while field_idx >= 0 {
        if first == 0 {
            emit(", ")
        }
        first = 0
        codegen_expr(field_idx)
        var field_node = g_nodes[field_idx]
        field_idx = field_node.extra
    }
    emit("}")
    return 0
}

fn codegen_expr(idx: int) -> int {
    if idx < 0 {
        return 0
    }
    var node = g_nodes[idx]
    if node.node_type == NodeType_NodeInt {
        codegen_int(node)
        return 0
    }
    if node.node_type == NodeType_NodeString {
        codegen_string(node)
        return 0
    }
    if node.node_type == NodeType_NodeVariable {
        codegen_variable(node)
        return 0
    }
    if node.node_type == NodeType_NodeBinary {
        codegen_binary(node)
        return 0
    }
    if node.node_type == NodeType_NodeCall {
        codegen_call(node)
        return 0
    }
    if node.node_type == NodeType_NodeStructInit {
        codegen_struct_init(node)
        return 0
    }
    return 0
}

fn codegen_var_decl(node: ASTNode) -> int {
    emit("int ")
    emit(node.value)
    emit(" = ")
    codegen_expr(node.left)
    emit(";\n")
    return 0
}

fn codegen_return(node: ASTNode) -> int {
    emit("return ")
    codegen_expr(node.left)
    emit(";\n")
    return 0
}

fn codegen_expr_stmt(node: ASTNode) -> int {
    codegen_expr(node.left)
    emit(";\n")
    return 0
}

fn codegen_if(node: ASTNode) -> int {
    emit("if (")
    codegen_expr(node.left)
    emit(") {\n")
    codegen_stmt(node.right)
    if node.extra >= 0 {
        emit("} else {\n")
        codegen_stmt(node.extra)
    }
    emit("}\n")
    return 0
}

fn codegen_while(node: ASTNode) -> int {
    emit("while (")
    codegen_expr(node.left)
    emit(") {\n")
    codegen_stmt(node.right)
    emit("}\n")
    return 0
}

fn codegen_block(node: ASTNode) -> int {
    var i = node.left
    while i >= 0 {
        codegen_stmt(i)
        var stmt = g_nodes[i]
        i = stmt.extra
    }
    return 0
}

fn codegen_fn_decl(node: ASTNode) -> int {
    emit("int ")
    emit(node.value)
    emit("(")
    var param_idx = node.left
    var first = 1
    while param_idx >= 0 {
        if first == 0 {
            emit(", ")
        }
        first = 0
        var param = g_nodes[param_idx]
        emit("int ")
        emit(param.value)
        param_idx = param.extra
    }
    emit(") {\n")
    codegen_stmt(node.right)
    emit("}\n")
    return 0
}

fn codegen_struct_decl(node: ASTNode) -> int {
    emit("typedef struct {\n")
    var field_idx = node.left
    while field_idx >= 0 {
        var field = g_nodes[field_idx]
        emit("    int ")
        emit(field.value)
        emit(";\n")
        field_idx = field.extra
    }
    emit("} ")
    emit(node.value)
    emit(";\n")
    return 0
}

fn codegen_enum_decl(node: ASTNode) -> int {
    emit("typedef enum {\n")
    var variant_idx = node.left
    var first = 1
    while variant_idx >= 0 {
        if first == 0 {
            emit(",\n")
        }
        first = 0
        var variant = g_nodes[variant_idx]
        emit("    ")
        emit(node.value)
        emit("_")
        emit(variant.value)
        variant_idx = variant.extra
    }
    emit("\n} ")
    emit(node.value)
    emit(";\n")
    return 0
}

fn codegen_match(node: ASTNode) -> int {
    emit("// match not yet implemented\n")
    return 0
}

fn codegen_program(root_idx: int) -> string {
    g_output = ""
    emit("#include <stdio.h>\n")
    emit("#include <stdlib.h>\n")
    emit("#include <string.h>\n\n")
    codegen_stmt(root_idx)
    return g_output
}

fn codegen_stmt(idx: int) -> int {
    if idx < 0 {
        return 0
    }
    var node = g_nodes[idx]
    if node.node_type == NodeType_NodeVarDecl {
        codegen_var_decl(node)
        return 0
    }
    if node.node_type == NodeType_NodeReturn {
        codegen_return(node)
        return 0
    }
    if node.node_type == NodeType_NodeExprStmt {
        codegen_expr_stmt(node)
        return 0
    }
    if node.node_type == NodeType_NodeIf {
        codegen_if(node)
        return 0
    }
    if node.node_type == NodeType_NodeWhile {
        codegen_while(node)
        return 0
    }
    if node.node_type == NodeType_NodeBlock {
        codegen_block(node)
        return 0
    }
    if node.node_type == NodeType_NodeFnDecl {
        codegen_fn_decl(node)
        return 0
    }
    if node.node_type == NodeType_NodeStructDecl {
        codegen_struct_decl(node)
        return 0
    }
    if node.node_type == NodeType_NodeEnumDecl {
        codegen_enum_decl(node)
        return 0
    }
    if node.node_type == NodeType_NodeMatch {
        codegen_match(node)
        return 0
    }
    return 0
}

fn main() -> int {
    // Test 1: Function declaration
    g_nodes.push(ASTNode { node_type: NodeType_NodeInt, value: "42", left: -1, right: -1, extra: -1 })
    g_nodes.push(ASTNode { node_type: NodeType_NodeReturn, value: "", left: 0, right: -1, extra: -1 })
    g_nodes.push(ASTNode { node_type: NodeType_NodeBlock, value: "", left: 1, right: -1, extra: -1 })
    g_nodes.push(ASTNode { node_type: NodeType_NodeFnDecl, value: "test", left: -1, right: 2, extra: -1 })
    
    var result = codegen_program(3)
    print("✓ Function codegen works!")
    
    // Test 2: Struct declaration
    g_output = ""
    g_nodes.push(ASTNode { node_type: NodeType_NodeVariable, value: "x", left: -1, right: -1, extra: 5 })
    g_nodes.push(ASTNode { node_type: NodeType_NodeVariable, value: "y", left: -1, right: -1, extra: -1 })
    g_nodes.push(ASTNode { node_type: NodeType_NodeStructDecl, value: "Point", left: 4, right: -1, extra: -1 })
    codegen_stmt(6)
    print("✓ Struct codegen works!")
    
    // Test 3: Enum declaration
    g_output = ""
    g_nodes.push(ASTNode { node_type: NodeType_NodeVariable, value: "Red", left: -1, right: -1, extra: 8 })
    g_nodes.push(ASTNode { node_type: NodeType_NodeVariable, value: "Blue", left: -1, right: -1, extra: -1 })
    g_nodes.push(ASTNode { node_type: NodeType_NodeEnumDecl, value: "Color", left: 7, right: -1, extra: -1 })
    codegen_stmt(9)
    print("✓ Enum codegen works!")
    
    print("✓ Complete codegen works!")
    return 0
}
