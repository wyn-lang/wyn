// Minimal parser - just validates token sequence
var tokens = ""
var pos = 0

fn at_end() -> int {
    if pos >= tokens.len() { return 1 }
    return 0
}

fn skip_to_next() -> int {
    while at_end() == 0 {
        var c = tokens.substring(pos, pos + 1)
        if c == "," {
            pos = pos + 1
            break
        }
        pos = pos + 1
    }
    return 0
}

fn match_tok(expected: string) -> int {
    var start = pos
    var i = 0
    while i < expected.len() {
        if at_end() == 1 { return 0 }
        var a = tokens.substring(pos, pos + 1)
        var b = expected.substring(i, i + 1)
        if a != b { 
            pos = start
            return 0 
        }
        pos = pos + 1
        i = i + 1
    }
    skip_to_next()
    return 1
}

fn parse_fn() -> int {
    if match_tok("FN") == 0 { return 0 }
    skip_to_next()
    if match_tok("LPAREN") == 0 { return 0 }
    skip_to_next()
    if match_tok("COLON") == 0 { return 0 }
    skip_to_next()
    if match_tok("RPAREN") == 0 { return 0 }
    if match_tok("ARROW") == 0 { return 0 }
    skip_to_next()
    if match_tok("LBRACE") == 0 { return 0 }
    if match_tok("RETURN") == 0 { return 0 }
    skip_to_next()
    if match_tok("RBRACE") == 0 { return 0 }
    return 1
}

fn main() -> int {
    tokens = "FN,ID:add,LPAREN,ID:a,COLON,ID:int,RPAREN,ARROW,ID:int,LBRACE,RETURN,ID:a,RBRACE"
    pos = 0
    var result = parse_fn()
    if result == 1 {
        print("Parser OK")
    }
    println()
    return 0
}
