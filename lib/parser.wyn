// Wyn Parser - Minimal Parser with Global State
// Phase 2: Parser in Wyn - Refactored for state management
// Solution: Use global variables (workaround for struct limitations)

// Token types
enum TokenType {
    EndOfFile,
    Ident,
    Int,
    String,
    Var,
    Return,
    Colon,
    Equal,
    Plus,
    Minus,
    Star,
    Slash,
    EqualEqual,
    BangEqual,
    Less,
    Greater,
    LessEqual,
    GreaterEqual,
    LeftParen,
    RightParen,
    LeftBrace,
    RightBrace,
    Comma,
    Fn,
    If,
    Else,
    While,
    Arrow,
    Struct,
    Enum,
    Match,
    DoubleColon
}

struct Token {
    tok_type: TokenType,
    value: string
}

// AST Node Types
enum NodeType {
    NodeInt,
    NodeString,
    NodeVariable,
    NodeVarDecl,
    NodeReturn,
    NodeExprStmt,
    NodeBinary,
    NodeFnDecl,
    NodeBlock,
    NodeIf,
    NodeWhile,
    NodeCall,
    NodeStructDecl,
    NodeEnumDecl,
    NodeMatch,
    NodeStructInit
}

// AST Node
struct ASTNode {
    node_type: NodeType,
    value: string,
    left: int,
    right: int,
    extra: int
}

// Global parser state
var g_tokens: [Token] = []
var g_current = 0
var g_nodes: [ASTNode] = []

// Peek current token
fn peek() -> Token {
    if g_current < g_tokens.len() {
        return g_tokens[g_current]
    }
    return Token { tok_type: TokenType_EndOfFile, value: "" }
}

// Check if current token matches type
fn check(tok_type: TokenType) -> int {
    var tok = peek()
    if tok.tok_type == tok_type {
        return 1
    }
    return 0
}

// Advance to next token
fn advance() {
    g_current = g_current + 1
}

// Add node and return its index
fn add_node(node: ASTNode) -> int {
    var idx = g_nodes.len()
    g_nodes.push(node)
    return idx
}

// Parse primary expression
fn parse_primary() -> int {
    var tok = peek()
    
    if tok.tok_type == TokenType_Int {
        advance()
        return add_node(ASTNode { 
            node_type: NodeType_NodeInt, 
            value: tok.value, 
            left: -1, 
            right: -1, 
            extra: -1 
        })
    }
    
    if tok.tok_type == TokenType_String {
        advance()
        return add_node(ASTNode { 
            node_type: NodeType_NodeString, 
            value: tok.value, 
            left: -1, 
            right: -1, 
            extra: -1 
        })
    }
    
    if tok.tok_type == TokenType_Ident {
        advance()
        var idx = add_node(ASTNode { 
            node_type: NodeType_NodeVariable, 
            value: tok.value, 
            left: -1, 
            right: -1, 
            extra: -1 
        })
        
        if check(TokenType_LeftParen) {
            advance()
            var args: [int] = []
            
            if check(TokenType_RightParen) == 0 {
                var arg_idx = parse_expr()
                args.push(arg_idx)
                
                while check(TokenType_Comma) {
                    advance()
                    arg_idx = parse_expr()
                    args.push(arg_idx)
                }
            }
            
            advance()
            return add_node(ASTNode { 
                node_type: NodeType_NodeCall, 
                value: "", 
                left: idx, 
                right: args.len(), 
                extra: -1 
            })
        }
        
        if check(TokenType_LeftBrace) {
            advance()
            
            while check(TokenType_RightBrace) == 0 && check(TokenType_EndOfFile) == 0 {
                var field_tok = peek()
                advance()
                
                if check(TokenType_Colon) {
                    advance()
                    var val_idx = parse_expr()
                }
                
                if check(TokenType_Comma) {
                    advance()
                }
            }
            
            advance()
            
            return add_node(ASTNode { 
                node_type: NodeType_NodeStructInit, 
                value: tok.value, 
                left: -1, 
                right: -1, 
                extra: -1 
            })
        }
        
        return idx
    }
    
    if tok.tok_type == TokenType_LeftParen {
        advance()
        var expr_idx = parse_expr()
        advance()
        return expr_idx
    }
    
    return -1
}

// Parse comparison expression
fn parse_comparison() -> int {
    var left = parse_primary()
    
    while check(TokenType_EqualEqual) || check(TokenType_BangEqual) || check(TokenType_Less) || check(TokenType_Greater) || check(TokenType_LessEqual) || check(TokenType_GreaterEqual) {
        var op_tok = peek()
        advance()
        var right = parse_primary()
        left = add_node(ASTNode { 
            node_type: NodeType_NodeBinary, 
            value: op_tok.value, 
            left: left, 
            right: right, 
            extra: -1 
        })
    }
    
    return left
}

// Parse factor expression (* /)
fn parse_factor() -> int {
    var left = parse_primary()
    
    while check(TokenType_Star) || check(TokenType_Slash) {
        var op_tok = peek()
        advance()
        var right = parse_primary()
        left = add_node(ASTNode { 
            node_type: NodeType_NodeBinary, 
            value: op_tok.value, 
            left: left, 
            right: right, 
            extra: -1 
        })
    }
    
    return left
}

// Parse term expression (+ -)
fn parse_term() -> int {
    var left = parse_factor()
    
    while check(TokenType_Plus) || check(TokenType_Minus) {
        var op_tok = peek()
        advance()
        var right = parse_factor()
        left = add_node(ASTNode { 
            node_type: NodeType_NodeBinary, 
            value: op_tok.value, 
            left: left, 
            right: right, 
            extra: -1 
        })
    }
    
    return left
}

// Parse expression
fn parse_expr() -> int {
    return parse_term()
}

// Parse variable declaration
fn parse_var_decl() -> int {
    advance()
    
    var name_tok = peek()
    advance()
    
    if name_tok.tok_type != TokenType_Ident {
        return -1
    }
    
    if check(TokenType_Colon) {
        advance()
        advance()
    }
    
    if check(TokenType_Equal) == 0 {
        return -1
    }
    
    advance()
    
    var expr_idx = parse_expr()
    return add_node(ASTNode { 
        node_type: NodeType_NodeVarDecl, 
        value: name_tok.value, 
        left: expr_idx, 
        right: -1, 
        extra: -1 
    })
}

// Parse block statement
fn parse_block() -> int {
    advance()
    var stmts: [int] = []
    
    while check(TokenType_RightBrace) == 0 && check(TokenType_EndOfFile) == 0 {
        var stmt_idx = parse_stmt()
        if stmt_idx >= 0 {
            stmts.push(stmt_idx)
        }
    }
    
    advance()
    
    return add_node(ASTNode { 
        node_type: NodeType_NodeBlock, 
        value: "", 
        left: -1, 
        right: stmts.len(), 
        extra: -1 
    })
}

// Parse if statement
fn parse_if() -> int {
    advance()
    var cond_idx = parse_expr()
    var then_idx = parse_block()
    var else_idx = -1
    
    if check(TokenType_Else) {
        advance()
        if check(TokenType_If) {
            else_idx = parse_if()
        } else {
            else_idx = parse_block()
        }
    }
    
    return add_node(ASTNode { 
        node_type: NodeType_NodeIf, 
        value: "", 
        left: cond_idx, 
        right: then_idx, 
        extra: else_idx 
    })
}

// Parse while statement
fn parse_while() -> int {
    advance()
    var cond_idx = parse_expr()
    var body_idx = parse_block()
    
    return add_node(ASTNode { 
        node_type: NodeType_NodeWhile, 
        value: "", 
        left: cond_idx, 
        right: body_idx, 
        extra: -1 
    })
}

// Parse struct declaration
fn parse_struct_decl() -> int {
    advance()
    
    var name_tok = peek()
    advance()
    
    advance()
    
    while check(TokenType_RightBrace) == 0 && check(TokenType_EndOfFile) == 0 {
        var field_tok = peek()
        advance()
        
        if check(TokenType_Colon) {
            advance()
            advance()
        }
        
        if check(TokenType_Comma) {
            advance()
        }
    }
    
    advance()
    
    return add_node(ASTNode { 
        node_type: NodeType_NodeStructDecl, 
        value: name_tok.value, 
        left: -1, 
        right: -1, 
        extra: -1 
    })
}

// Parse enum declaration
fn parse_enum_decl() -> int {
    advance()
    
    var name_tok = peek()
    advance()
    
    advance()
    
    while check(TokenType_RightBrace) == 0 && check(TokenType_EndOfFile) == 0 {
        var variant_tok = peek()
        advance()
        
        if check(TokenType_Comma) {
            advance()
        }
    }
    
    advance()
    
    return add_node(ASTNode { 
        node_type: NodeType_NodeEnumDecl, 
        value: name_tok.value, 
        left: -1, 
        right: -1, 
        extra: -1 
    })
}

// Parse function declaration
fn parse_fn_decl() -> int {
    advance()
    
    var name_tok = peek()
    advance()
    
    advance()
    
    if check(TokenType_RightParen) == 0 {
        var param_tok = peek()
        advance()
        
        if check(TokenType_Colon) {
            advance()
            advance()
        }
        
        while check(TokenType_Comma) {
            advance()
            param_tok = peek()
            advance()
            
            if check(TokenType_Colon) {
                advance()
                advance()
            }
        }
    }
    
    advance()
    
    if check(TokenType_Arrow) {
        advance()
        advance()
    }
    
    var body_idx = parse_block()
    
    return add_node(ASTNode { 
        node_type: NodeType_NodeFnDecl, 
        value: name_tok.value, 
        left: body_idx, 
        right: -1, 
        extra: -1 
    })
}

// Parse match expression
fn parse_match() -> int {
    advance()
    var expr_idx = parse_expr()
    
    advance()
    
    while check(TokenType_RightBrace) == 0 && check(TokenType_EndOfFile) == 0 {
        var pattern_idx = parse_expr()
        
        if check(TokenType_Arrow) {
            advance()
        }
        
        var body_idx = parse_stmt()
        
        if check(TokenType_Comma) {
            advance()
        }
    }
    
    advance()
    
    return add_node(ASTNode { 
        node_type: NodeType_NodeMatch, 
        value: "", 
        left: expr_idx, 
        right: -1, 
        extra: -1 
    })
}

// Parse statement
fn parse_stmt() -> int {
    var tok = peek()
    
    if tok.tok_type == TokenType_Var {
        return parse_var_decl()
    }
    
    if tok.tok_type == TokenType_Return {
        advance()
        var expr_idx = parse_expr()
        return add_node(ASTNode { 
            node_type: NodeType_NodeReturn, 
            value: "", 
            left: expr_idx, 
            right: -1, 
            extra: -1 
        })
    }
    
    if tok.tok_type == TokenType_If {
        return parse_if()
    }
    
    if tok.tok_type == TokenType_While {
        return parse_while()
    }
    
    if tok.tok_type == TokenType_Match {
        return parse_match()
    }
    
    if tok.tok_type == TokenType_LeftBrace {
        return parse_block()
    }
    
    var expr_idx = parse_expr()
    return add_node(ASTNode { 
        node_type: NodeType_NodeExprStmt, 
        value: "", 
        left: expr_idx, 
        right: -1, 
        extra: -1 
    })
}

// Parse program (list of declarations)
fn parse(tokens: [Token]) -> [int] {
    g_tokens = tokens
    g_current = 0
    g_nodes = []
    
    var decls: [int] = []
    
    while check(TokenType_EndOfFile) == 0 {
        var tok = peek()
        
        if tok.tok_type == TokenType_Fn {
            var fn_idx = parse_fn_decl()
            if fn_idx >= 0 {
                decls.push(fn_idx)
            }
        } else if tok.tok_type == TokenType_Struct {
            var struct_idx = parse_struct_decl()
            if struct_idx >= 0 {
                decls.push(struct_idx)
            }
        } else if tok.tok_type == TokenType_Enum {
            var enum_idx = parse_enum_decl()
            if enum_idx >= 0 {
                decls.push(enum_idx)
            }
        } else {
            var stmt_idx = parse_stmt()
            if stmt_idx >= 0 {
                decls.push(stmt_idx)
            }
        }
    }
    
    return decls
}

// Main entry point
fn main() -> int {
    print("Wyn Parser - Phase 2 Extended (Structs, Enums, Match)\n")
    print("State management: global variables\n")
    
    var tokens: [Token] = []
    tokens.push(Token { tok_type: TokenType_Struct, value: "struct" })
    tokens.push(Token { tok_type: TokenType_Ident, value: "Point" })
    tokens.push(Token { tok_type: TokenType_LeftBrace, value: "{" })
    tokens.push(Token { tok_type: TokenType_Ident, value: "x" })
    tokens.push(Token { tok_type: TokenType_Colon, value: ":" })
    tokens.push(Token { tok_type: TokenType_Ident, value: "int" })
    tokens.push(Token { tok_type: TokenType_Comma, value: "," })
    tokens.push(Token { tok_type: TokenType_Ident, value: "y" })
    tokens.push(Token { tok_type: TokenType_Colon, value: ":" })
    tokens.push(Token { tok_type: TokenType_Ident, value: "int" })
    tokens.push(Token { tok_type: TokenType_RightBrace, value: "}" })
    tokens.push(Token { tok_type: TokenType_EndOfFile, value: "" })
    
    var decls = parse(tokens)
    if decls.len() > 0 {
        print("Successfully parsed struct declaration\n")
    }
    
    print("Parser extended with structs, enums, and match!\n")
    
    return 0
}
