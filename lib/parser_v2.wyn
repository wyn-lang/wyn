// Parser for Wyn written in Wyn
// Using int constants instead of enums to work around type system limitations

// Token types as constants
var TOK_EOF = 0
var TOK_INT = 1
var TOK_IDENT = 2
var TOK_PLUS = 3

// Node types as constants  
var NODE_INT = 10
var NODE_IDENT = 11
var NODE_BINARY = 12

// Parser state
var g_tokens = []
var g_pos = 0

fn peek() -> int {
    if g_pos < g_tokens.len() {
        return g_tokens[g_pos]
    }
    return TOK_EOF
}

fn advance() -> int {
    var tok = peek()
    g_pos = g_pos + 1
    return tok
}

fn parse_primary() -> int {
    var tok = peek()
    
    if tok == TOK_INT {
        advance()
        return NODE_INT
    }
    
    if tok == TOK_IDENT {
        advance()
        return NODE_IDENT
    }
    
    return NODE_INT
}

fn parse_expr() -> int {
    var left = parse_primary()
    
    var tok = peek()
    if tok == TOK_PLUS {
        advance()
        var right = parse_primary()
        return NODE_BINARY
    }
    
    return left
}

fn parse(token_array: [int]) -> int {
    g_tokens = token_array
    g_pos = 0
    return parse_expr()
}

fn main() -> int {
    var test_tokens = []
    test_tokens.push(TOK_INT)
    test_tokens.push(TOK_PLUS)
    test_tokens.push(TOK_INT)
    test_tokens.push(TOK_EOF)
    
    var ast = parse(test_tokens)
    
    if ast == NODE_BINARY {
        print("âœ“ Parser works!")
        return 0
    }
    
    return 1
}
