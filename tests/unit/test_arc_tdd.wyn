// TDD Test Suite for ARC (Automatic Reference Counting)
// These tests will FAIL with current stack-only implementation

use std::test;
use std::mem;

struct TestObject {
    value: int,
    id: int
}

// Test 1: Basic heap allocation
fn test_basic_heap_allocation() {
    let obj = Box::new(TestObject { value: 42, id: 1 });
    
    // Should be heap allocated, not stack
    let heap_addr = mem::heap_address(&obj);
    let stack_addr = mem::stack_address(&obj);
    
    test::assert_ne(heap_addr, stack_addr, "Object should be heap allocated");
    test::assert_true(mem::is_heap_allocated(&obj), "Box should allocate on heap");
}

// Test 2: Reference counting increment
fn test_ref_count_increment() {
    let obj = Box::new(TestObject { value: 100, id: 2 });
    
    test::assert_eq(obj.ref_count(), 1, "Initial ref count should be 1");
    
    let obj2 = obj.clone();
    test::assert_eq(obj.ref_count(), 2, "Ref count should increment to 2");
    test::assert_eq(obj2.ref_count(), 2, "Both refs should show count 2");
}

// Test 3: Reference counting decrement  
fn test_ref_count_decrement() {
    let obj = Box::new(TestObject { value: 200, id: 3 });
    
    {
        let obj2 = obj.clone();
        test::assert_eq(obj.ref_count(), 2, "Ref count should be 2");
    } // obj2 goes out of scope
    
    test::assert_eq(obj.ref_count(), 1, "Ref count should decrement to 1");
}

// Test 4: Automatic cleanup at zero refs
fn test_automatic_cleanup() {
    let cleanup_called = false;
    
    {
        let obj = Box::new(TestObject { value: 300, id: 4 });
        obj.set_destructor(|| { cleanup_called = true; });
        
        test::assert_eq(obj.ref_count(), 1, "Ref count should be 1");
    } // obj goes out of scope, ref count becomes 0
    
    test::assert_true(cleanup_called, "Destructor should be called when ref count reaches 0");
}

// Test 5: Multiple references to same object
fn test_multiple_references() {
    let obj = Box::new(TestObject { value: 400, id: 5 });
    let obj2 = obj.clone();
    let obj3 = obj.clone();
    let obj4 = obj2.clone();
    
    test::assert_eq(obj.ref_count(), 4, "All refs should show count 4");
    test::assert_eq(obj2.ref_count(), 4, "All refs should show count 4");
    test::assert_eq(obj3.ref_count(), 4, "All refs should show count 4");
    test::assert_eq(obj4.ref_count(), 4, "All refs should show count 4");
    
    // Verify they point to same memory
    test::assert_eq(mem::address(&obj), mem::address(&obj2), "Should point to same memory");
    test::assert_eq(mem::address(&obj), mem::address(&obj3), "Should point to same memory");
    test::assert_eq(mem::address(&obj), mem::address(&obj4), "Should point to same memory");
}

fn main() -> int {
    test::run("Basic heap allocation", test_basic_heap_allocation);
    test::run("Reference counting increment", test_ref_count_increment);
    test::run("Reference counting decrement", test_ref_count_decrement);
    test::run("Automatic cleanup", test_automatic_cleanup);
    test::run("Multiple references", test_multiple_references);
    
    return 0;
}